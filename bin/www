#!/usr/bin/env node

var app = require('../app');
var debug = require('debug')('potfund:server');
var http = require('http');
var models = require('../models');
var sleep = require('sleep');
var es = require('../elasticsearch');
var elasticsearchModels = require('../elasticsearch/model');
var async = require('async');
var stripe = require('stripe')("sk_test_pMhjrnm4PHA6cA5YZtmoD0dv");
var nodemailer = require('nodemailer');
var smtpTransport = require('nodemailer-smtp-transport');
var transporter = nodemailer.createTransport('smtps://user%40gmail.com:pass@smtp.gmail.com');
var fund_array_to_json = function(array) {
  var funds = array.map(function(fund) {
    var json = fund.toJSON();
    return json;
  });
  return funds;
};

var fields = ["application_decision_date","application_documents","application_open_date","title","tags","maximum_amount","minimum_amount","country_of_residence","description","duration_of_scholarship","email","application_link","maximum_age","minimum_age","invite_only","interview_date","link","religion","gender","financial_situation","specific_location","subject","target_degree","target_university","required_degree","required_grade","required_university","merit_or_finance","deadline","target_country","number_of_places", "support_type","organisation_id"];
var userFields =  ["username","profile_picture","description","past_work","date_of_birth","subject", "country_of_residence", "target_country", "religion","funding_needed","organisation_or_user", "previous_degree", "previous_university", "target_university", "target_degree","completion_date", "favourite_funds"];

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

var server = http.createServer(app);

/* Socket IO Messaging Component */

var io = require('socket.io')(server);
var users = {};

io.on('connection', function(socket){
  Logger.info('a user connected');

  socket.on('disconnect', function(){
    Logger.info('user disconnected');
  });

  socket.on('private message', function(data) {
    Logger.info("USERS");
    Logger.info(users);

    Logger.info(data);
    if (users[data.userToID]) {
      users[data.userToID].socket.join(data.roomName);
    }
    users[data.userFromID].socket.join(data.roomName);

    var rooms = io.sockets.adapter.rooms;
    Logger.info("Clients in rooms:");
    Logger.info(rooms);



    var user_to_arr = [];
    user_to_arr.push(data.userToID);
    var read_by_recipient = false;

    var socketsInRoom = Object.keys(io.sockets.adapter.rooms[data.roomName].sockets);
    var senderSID = socket.id;

    if (socketsInRoom.length !== 1 && socketsInRoom.indexOf(senderSID)) {
      if (users[data.userToID]) {
        if (users[data.userToID].socket.readyToReceiveFrom == data.userFromID ) {
          read_by_recipient = true;
          data.read_by_recipient = true;
        }
      }
    }

    models.messages.create({
      user_from: data.userFromID,
      user_to: user_to_arr,
      message: data.msg,
      room_name: data.roomName,
      read_by_recipient: read_by_recipient
    });
    io.sockets.in(data.roomName).emit('private message', data);
  });

  socket.on('add user', function(data) {
    users[data.userFrom.id] = { "socket" : socket };
    Logger.info("A new user has been added. Here is the users object:");
    Logger.info(users);
  });

  socket.on('room join', function(data) {

  });

  socket.on('get messages', function(data) {
    var userToID_arr = [];
    userToID_arr.push(data.userToID);
    var userFromID_arr = [];
    userFromID_arr.push(data.userFromID);

    // NOTE: readyToReceiveFrom also means it has read latest message
    console.log(data.userToID);
    models.users.findById(data.userToID).then(function(userTo) {
      userTo = userTo.get();

      data.userTo = userTo;

      Logger.error(data.roomName);
      Logger.error(userFromID_arr);
      models.messages.update({ read_by_recipient: true },
        {
          where: {
            room_name: data.roomName,
            user_to: {
              $contains: userFromID_arr
            }
          }
        }
      ).spread(function(affectedCount, affectedRows) {
        retrieveAllMessagesInRoom(data);
      });
    });
  });
});

/* ---------------------------- */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

es.checkConnection().then(function(resp) {
  if (resp) {
    Logger.info("Connected to elasticsearch.");
    var countries = require('../resources/countries');
    var religions = require('../resources/religions');
    var degrees = require('../resources/degrees');
    var universities = require('../resources/universities');
    var subjects = require('../resources/subjects');

    es.indexExists('funds')
      .then(es.deleteIndex('funds'))
      .then(es.createIndex('funds'))
      .then(bulkUploadFunds)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "rest of the world" }, countries.rotw); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "africa" }, countries.africanCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "eu" }, countries.euCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "middle east" }, countries.meCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "asia" }, countries.asianCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('religions', null, religions.religions); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "undergraduate" }, degrees.undergradDegrees); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "postgraduate masters" }, degrees.gradDegrees); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "uk" }, universities.ukUniversities); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "us" }, universities.usUniversities); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "misc" }, subjects.miscSubjects); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "modern languages" }, subjects.modernLanguages); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "humanities" }, subjects.humanities); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "education" }, subjects.education); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "arts" }, subjects.arts); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "social sciences" }, subjects.socialSciences); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "science" }, subjects.sciences); })
      .then(bulkUpload);

    es.indexExists('users')
      .then(es.deleteIndex('users'))
      .then(es.createIndex('users'))
      .then(bulkUploadUsers);
  }
});

// TODO: check queue for duplications! Duplications MAY occur due to timestamp rounding error
// TODO: Eventually have to implement queuing system? Querying whole funds table is high volume.

var CronJob = require('cron').CronJob;
var lastUpdate = new Date();
var job = new CronJob('*/30 * * * * *', checkForChanges, null, true);

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
///////////////////////    Helper functions    /////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//TODO: change interval to 1 day
var fundUnreadMessagesScheduler = new CronJob('00 00 12 * * *', checkForFundUnreadMessages, null, true);
var checkRefund = new CronJob('00 00 00 * * *', checkForRefund, null, true);

function checkForFundUnreadMessages() {
  return models.sequelize.query('SELECT user_to, COUNT(*) FROM messages WHERE read_by_recipient = false GROUP BY user_to HAVING COUNT(*) > 0').spread(function(results, metadata) {
    Logger.error("^^^^^^^^^^^^^^^^^^^^^^^^^^^");
    Logger.error(results);
    var userIDList = [];
    var emailStats = {};
    results.forEach(function(result) {
      userIDList.push(result.user_to[0]);
      // Restructure data to be used for sending emails
      emailStats[result.user_to[0]] = {};
      emailStats[result.user_to[0]].unreadCount = result.count;
      emailStats.user_from = result.user_from;
    });
    return models.users.findAll({
      where: { id: userIDList },
      attributes: ['id', 'email', 'username']
    }).then(function(users) {
      users.forEach(function(user) {
        emailStats[user.id].email = user.email;
        var username = user.username.split(' ')[0];
        //send emails here
        var transporter = nodemailer.createTransport(smtpTransport({
         service: 'Gmail',
         auth: {user: 'james.morrill.6@gmail.com',
               pass: 'exogene5i5'}
        }));
        var mailOptions = {
           from: 'Silofunds <james.morrill.6@gmail.com>',
           to: user.email,
           subject: 'You have new unread messages!',
           html: '<h3>Dear ' + username + '</h3> <p> You are receiving this because you have recieved new messages on our platform. Please click on the following <a href="https://silofunds.com/user/messages">link </a> to read them.</p><img src="https://www.silofunds.com/images/silo-logo-coloured.png" style="width: 250px; height: 137px"> </img>'
        };
        transporter.sendMail(mailOptions, function(error, response) {
            if (error) {
                console.log("Email send failed");
            }
            else {
              console.log("SUCCESS");
            }
        });
      });
    });
  });
}
function checkForRefund(){

  return models.users.findAll({where: {organisation_or_user: null}}).then(function(users){
    async.each(users, function(user, callback){
      //check each user - if funding_accrued < funding_needed && completiont date is over AND they refund, then refund.
      var date = new Date();
      var userId = user.id;
      if(user.completion_date && user.funding_accrued < user.funding_needed && date > user.completion_date && user.refund){
        console.log("Got in")
        models.stripe_users.find({where: {user_id: userId}}).then(function(stripe_user){
          var stripe_acct_id = stripe_user.stripe_user_id;
          models.stripe_charges.findAll({where: {destination_id: stripe_acct_id}}).then(function(charge_array){
             asyncRefund(charge_array, callback);
          });
        });
      }
      else{
        callback();
      }
    }, function done(){
      return true;
    });
  });
}
function retrieveAllMessagesInRoom(data) {
  return models.messages.findAll({ where: {
    room_name: data.roomName
  }}).then(function(messages) {
    messages = messages.map(function(message) {
      return message.get();
    });

    Logger.info('Retrieved messages:');
    Logger.info(messages);

    if (users[data.userToID]) {
      users[data.userToID].socket.join(data.roomName);
    }
    users[data.userFromID].socket.join(data.roomName);
    users[data.userFromID].socket.readyToReceiveFrom = data.readyToReceiveFrom;
    Logger.info("user " + data.userFromID + " is ready to receive from " + data.readyToReceiveFrom);

    data.bulk_messages = messages;

    io.sockets.in(data.roomName).emit('bulk get message', data);
  });
}

function checkForChanges() {
  var log = 'Last updated: ' + lastUpdate;

  models.funds.findAll({
    where: {
      created_at: {
        $gte: lastUpdate
      }
    },
    order: 'created_at ASC'
  }).then(function(funds) {
    if (funds.length === 0) {
      Logger.info("nothing to update....");
    } else {
      var wrapper = {};
      var body = prepareBulkUploadFunds(funds);

      wrapper.fieldName = 'funds';
      wrapper.body = body;

      bulkUpload(wrapper).then(function() {
        // Timestamp from table rounds down. Here is the correction to avoid duplication.
        var lastUpdateFromTable = funds[funds.length - 1].created_at;
        lastUpdateFromTable.setSeconds(lastUpdateFromTable.getSeconds() + 1);
        lastUpdate = lastUpdateFromTable;
      });
    }
  }).then(function(){
    models.users.findAll({
      where: {
        created_at: {
          $gte: lastUpdate
        },
        organisation_or_user: null
      },
      order: 'created_at ASC'
    }).then(function(users){
      if(users.length === 0){
        Logger.info('nothing to update');
      }else{
        var wrapper = {};
        var body = prepareBulkUploadUsers(users);
        wrapper.fieldName = 'users';
        wrapper.body = body;
        bulkUpload(wrapper).then(function(){
          // Timestamp from table rounds down. Here is the correction to avoid duplication.
          var lastUpdateFromTable = funds[funds.length - 1].created_at;
          lastUpdateFromTable.setSeconds(lastUpdateFromTable.getSeconds() + 1);
          lastUpdate = lastUpdateFromTable;
        });
      }
    });
  });
}

function loadSettingsForBulkPrepFor(typeName, extraOptions, dataSource) {
  var wrapper = {};
  var body = prepareBulkUploadAutocomplete(typeName, elasticsearchModels.autocompleteSettings[typeName], extraOptions, dataSource);

  wrapper.fieldName = typeName;
  wrapper.body = body;
  return wrapper;
}

function prepareBulkUploadFunds(funds) {
  var body = [];
  funds = fund_array_to_json(funds);

  // Prepare body for _bulk processing. Each element in body array HAS to be an object.
  funds.forEach(function(fund) {
    body.push({'index': {'_index': 'funds', '_type': 'fund', '_id': fund.id}});
    var wrapper = {};

    for (var i = 0; i < fields.length ; i++) {
      wrapper[fields[i]] = fund[fields[i]];
    }

    wrapper["suggest_funds"] = { "input": fund.tags };

    body.push(wrapper);
  });

  return body;
}

function prepareBulkUploadUsers(users) {
  var userBody = [];
  users = fund_array_to_json(users);

  // Prepare body for _bulk processing. Each element in body array HAS to be an object.
  users.forEach(function(user) {
    userBody.push({'index': {'_index': 'users', '_type': 'user', '_id': user.id}});
    var wrapper = {};

    for (var i = 0; i < userFields.length ; i++) {
      wrapper[userFields[i]] = user[userFields[i]];
    }

    wrapper.suggest = { "input": user.username };

    userBody.push(wrapper);
  });

  return userBody;
}

function prepareBulkUploadAutocomplete(typeName, keyOptions, extraOptions, dataSource) {
  var bodyArray =[];
  var type = 'autocomplete_' + typeName;

  // Extra field for degrees ("abbreviated_degree") to handle abbreviations
  if (typeName === 'degrees') {
    // Currently only degrees.js has format in array of JSON
    dataSource.forEach(function(data){
      // NOTE: Careful with future Object.prototype keys manipulation
      for (var key in data) {
        var payloadOptions = {};

        payloadOptions[keyOptions.payloadKey] = data[key];

        bodyArray.push({'index': {'_index': 'funds', '_type': type }});
        var wrapper = {};

        wrapper[keyOptions.normalFieldName] = data[key];
        wrapper[keyOptions.suggestFieldName] = { "input": data[key].split(' '), "output": data[key], "payload": payloadOptions};

        if (extraOptions) {
          var extraOptionsKeys = Object.keys(extraOptions);

          for (var i = 0; i < extraOptionsKeys.length; i++) {
            var extraOptionsKey = extraOptionsKeys[i];
            wrapper[extraOptionsKey] = extraOptions[extraOptionsKey];
          }
        }

        // The only thing different from the else case below.
        wrapper.abbreviated_degree = key;

        bodyArray.push(wrapper);
      }
    });
  } else {
    dataSource.forEach(function(data){
      var payloadOptions = {};
      payloadOptions[keyOptions.payloadKey] = data;

      bodyArray.push({'index': {'_index': 'funds', '_type': type }});
      var wrapper = {};

      wrapper[keyOptions.normalFieldName] = data;
      wrapper[keyOptions.suggestFieldName] = { "input": data.split(' '), "output": data, "payload": payloadOptions};

      if (extraOptions) {
        var extraOptionsKeys = Object.keys(extraOptions);

        for (var i = 0; i < extraOptionsKeys.length; i++) {
          var extraOptionsKey = extraOptionsKeys[i];
          wrapper[extraOptionsKey] = extraOptions[extraOptionsKey];
        }
      }

      bodyArray.push(wrapper);
    });
  }

  return bodyArray;
}

function bulkUploadUsers() {
  return models.users.findAll().then(prepareBulkUploadUsers).then(function(body) {
    bulkUpload({
      body: body,
      fieldName: 'users'
    });
  });
}

function bulkUploadFunds() {
  return models.funds.findAll().then(prepareBulkUploadFunds).then(function(body) {
    bulkUpload({
      body: body,
      fieldName: 'funds'
    });
  });
}

function bulkUpload(data) {
  return es.bulk({
            body: data.body
          }).catch(function(err) {
            Logger.info("Error bulk syncing " + data.fieldName + " into funds index:");
            Logger.info(err);
          }).then(function(resp) {
            if (resp) {
              Logger.info("Bulk sync for " + data.fieldName + " complete");
            }
          });
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */
 function asyncRefund(chargeArray, mainCallback){
   async.each(chargeArray, function(charge, callback){
     stripe.refunds.create({
       charge: charge.charge_id
     }, function(err, refund){
       Logger.error(refund);
       callback();
     });
   }, function done(){
     mainCallback();
   });
 }
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
