#!/usr/bin/env node

var app = require('../app');
var debug = require('debug')('potfund:server');
var http = require('http');
var models = require('../models');
var sleep = require('sleep');
var es = require('../elasticsearch');
var elasticsearchModels = require('../elasticsearch/model');
var async = require('async');
var stripe = require('stripe')("sk_test_pMhjrnm4PHA6cA5YZtmoD0dv");
var nodemailer = require('nodemailer');
var smtpTransport = require('nodemailer-smtp-transport');
var path = require('path');
var transporter = nodemailer.createTransport('smtps://user%40gmail.com:pass@smtp.gmail.com');
var fund_array_to_json = function(array) {
  var funds = array.map(function(fund) {
    var json = fund.toJSON();
    return json;
  });
  return funds;
};

var fields = ["application_decision_date","application_documents","application_open_date","title","tags","maximum_amount","minimum_amount","country_of_residence","description","duration_of_scholarship","email","application_link","maximum_age","minimum_age","invite_only","interview_date","link","religion","gender","financial_situation","specific_location","subject","target_degree","target_university","required_degree","required_grade","required_university","required_college", "merit_or_finance","deadline","target_country","number_of_places", "support_type","organisation_id"];
var userFields =  ["username","profile_picture","description","past_work","date_of_birth","subject", "country_of_residence", "target_country", "religion","funding_needed","organisation_or_user", "previous_degree", "previous_university", "target_university", "target_degree","completion_date", "favourite_funds", "removed_funds", "college"];

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

var server = http.createServer(app);

/* Socket IO Messaging Component */

var io = require('socket.io')(server);
var users = {};

io.on('connection', function(socket){
  Logger.info('a user connected');

  socket.on('disconnect', function(){
    Logger.info('user disconnected');
  });

  socket.on('private message', function(data) {
    Logger.info("USERS");
    Logger.info(users);

    Logger.info(data);
    if (users[data.userToID]) {
      users[data.userToID].socket.join(data.roomName);
    }
    users[data.userFromID].socket.join(data.roomName);

    var rooms = io.sockets.adapter.rooms;
    Logger.info("Clients in rooms:");
    Logger.info(rooms);



    var user_to_arr = [];
    user_to_arr.push(data.userToID);
    var read_by_recipient = false;

    var socketsInRoom = Object.keys(io.sockets.adapter.rooms[data.roomName].sockets);
    var senderSID = socket.id;

    if (socketsInRoom.length !== 1 && socketsInRoom.indexOf(senderSID)) {
      if (users[data.userToID]) {
        if (users[data.userToID].socket.readyToReceiveFrom == data.userFromID ) {
          read_by_recipient = true;
          data.read_by_recipient = true;
        }
      }
    }

    models.messages.create({
      user_from: data.userFromID,
      user_to: user_to_arr,
      message: data.msg,
      room_name: data.roomName,
      read_by_recipient: read_by_recipient
    });
    io.sockets.in(data.roomName).emit('private message', data);
  });

  socket.on('add user', function(data) {
    users[data.userFrom.id] = { "socket" : socket };
    Logger.info("A new user has been added. Here is the users object:");
    Logger.info(users);
  });

  socket.on('room join', function(data) {

  });

  socket.on('get messages', function(data) {
    var userToID_arr = [];
    userToID_arr.push(data.userToID);
    var userFromID_arr = [];
    userFromID_arr.push(data.userFromID);

    // NOTE: readyToReceiveFrom also means it has read latest message
    console.log(data.userToID);
    models.users.findById(data.userToID).then(function(userTo) {
      userTo = userTo.get();

      data.userTo = userTo;

      Logger.error(data.roomName);
      Logger.error(userFromID_arr);
      models.messages.update({ read_by_recipient: true },
        {
          where: {
            room_name: data.roomName,
            user_to: {
              $contains: userFromID_arr
            }
          }
        }
      ).spread(function(affectedCount, affectedRows) {
        retrieveAllMessagesInRoom(data);
      });
    });
  });
});

/* ---------------------------- */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

es.checkConnection().then(function(resp) {
  if (resp) {
    Logger.info("Connected to elasticsearch.");
    var countries = require('../resources/countries');
    var religions = require('../resources/religions');
    var degrees = require('../resources/degrees');
    var universities = require('../resources/universities');
    var subjects = require('../resources/subjects');

    es.indexExists('funds', function(resp){
      if(resp){
        es.deleteIndex('funds').then(es.createIndex('funds'))
          .then(bulkUploadFunds)
          .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "rest of the world" }, countries.rotw); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "africa" }, countries.africanCountries); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "eu" }, countries.euCountries); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "middle east" }, countries.meCountries); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "asia" }, countries.asianCountries); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('religions', null, religions.religions); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "undergraduate" }, degrees.undergradDegrees); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "postgraduate masters" }, degrees.gradDegrees); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "uk" }, universities.ukUniversities); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "us" }, universities.usUniversities); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "misc" }, subjects.miscSubjects); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "modern languages" }, subjects.modernLanguages); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "humanities" }, subjects.humanities); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "education" }, subjects.education); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "arts" }, subjects.arts); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "social sciences" }, subjects.socialSciences); })
          .then(bulkUpload)
          .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "science" }, subjects.sciences); })
          .then(bulkUpload)
          .then(es.indexExists('users', function(resp){
            if(resp){
              es.deleteIndex('users')
              .then(es.createIndex('users'))
              .then(bulkUploadUsers);
            }
            else{
              es.createIndex('users')
              .then(bulkUploadUsers);
            }
          }));
      }
      else{
        es.createIndex('funds')
        .then(bulkUploadFunds)
        .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "rest of the world" }, countries.rotw); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "africa" }, countries.africanCountries); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "eu" }, countries.euCountries); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "middle east" }, countries.meCountries); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "asia" }, countries.asianCountries); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('religions', null, religions.religions); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "undergraduate" }, degrees.undergradDegrees); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "postgraduate masters" }, degrees.gradDegrees); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "uk" }, universities.ukUniversities); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "us" }, universities.usUniversities); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "misc" }, subjects.miscSubjects); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "modern languages" }, subjects.modernLanguages); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "humanities" }, subjects.humanities); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "education" }, subjects.education); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "arts" }, subjects.arts); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "social sciences" }, subjects.socialSciences); })
        .then(bulkUpload)
        .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "science" }, subjects.sciences); })
        .then(bulkUpload)
        .then(es.indexExists('users', function(resp){
          if(resp){
            es.deleteIndex('users')
            .then(es.createIndex('users'))
            .then(bulkUploadUsers);
          }
          else{
            es.createIndex('users')
            .then(bulkUploadUsers);
          }
        }));
      }
    });

  }
});

// TODO: check queue for duplications! Duplications MAY occur due to timestamp rounding error
// TODO: Eventually have to implement queuing system? Querying whole funds table is high volume.

var CronJob = require('cron').CronJob;
var lastUpdate = new Date();
var job = new CronJob('*/30 * * * * *', checkForChanges, null, true);

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
///////////////////////    Helper functions    /////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//
var checkIndexScheduler = new CronJob('0 0 * * * *', checkIndices, null, true);
var fundUnreadMessagesScheduler = new CronJob('0 0 */3 * * *', checkForFundUnreadMessages, null, true);
var checkRefundScheduler = new CronJob('00 00 23 * * *', checkForRefund, null, true);
var weeklyFundNewsLetterScheduler = new CronJob('0 5 8 * * 1', weeklyFundNewsLetter, null, true );
var weeklyStudentNewsLetterScheduler = new CronJob('0 40 10 * * 0', weeklyStudentNewsLetter, null, true);
// var weeklyStudentNewsLetterScheduler = new CronJob('0 */1 * * * *', weeklyStudentNewsLetter, null, true);
var EmailTemplate = require('email-templates').EmailTemplate;
var signupFreshersTemplate = new CronJob('0 */15 * * * *', signupFreshers, null, true);

function signupFreshers(){
  console.log("SIGNING UP FRESHERS");
  models.users.findAll({where: {freshers_signup: true, freshers_email_sent: null}}).then(function(users){
    //Don't forget to slice users!
  if(users.length > 0){
    users = users.slice(0,100);
    console.log("USER LENGTH", users.length);
    var unsentEmailArray = [];
    async.each(users, function(user, callback){
      var loginEmail = user.email;
      var nameArray = user.username.split(' ');
      var lastName = nameArray[nameArray.length - 1].toLowerCase();
      var password;
      if(user.date_of_birth){
        var birthYear = new Date(user.date_of_birth);
        birthYear = birthYear.getFullYear().toString();
        var shortForm = birthYear.slice(-2);
        password = lastName + shortForm;
      }
      else{
        password = lastName;
      }
      var locals = {
        header: "Dear " + nameArray[0] + ',',
        loginEmail: "Email: " +loginEmail,
        password: "Password: " + password,
        user_id: user.id
      };
      var transporter = nodemailer.createTransport(smtpTransport({
       service: 'Gmail',
       auth: {user: 'notifications@silofunds.com',
             pass: 'ThisIsNotificationsAccount'}
      }));
      var templatePath = path.join(process.cwd(), 'email-templates/freshers-signup-template');
      var template = new EmailTemplate(templatePath);
      template.render(locals, function(err, results){
        if (err) {
           callback();
           return console.error(err);
        }
        transporter.sendMail({
          from: 'Silofunds',
          to: user.email,
          subject: "Fresher's Signup Log-in details",
          html: results.html
        }, function(err, responseStatus){
          if (err) {
           console.error(err);
           console.log("USER ERROR", user.email);
           unsentEmailArray.push(user.email);
           callback();
          }
          else{
            console.log("SUCCESS");
            console.log("USER", user.email);
            console.log(responseStatus);
            models.users.findById(user.id).then(function(user){
              user.update({freshers_email_sent: true}).then(function(){
                callback();
              });
            });
          }

        });
      });

    });
  }
  });
}

function weeklyFundNewsLetter(){
  var oneDay = 24*60*60*1000;
  var nowDate = Date.now();
  var oneWeekAgo = new Date();
  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  models.users.findAll({where: {organisation_or_user: {$ne: null}}}).then(function(users){
    async.each(users, function(user, firstCallback){
      models.funds.findAll({where: {organisation_id: user.organisation_or_user}}).then(function(funds){
        //check favourites, check page views, check apps
        var emailArray = [];
        async.each(funds, function(fund, fundCallback){
          var emailObj = {};
          emailObj['fund_title'] = fund.title;
          checkFavourite(fund, oneWeekAgo, function(favouriteFunds){
            emailObj['favourites'] = favouriteFunds.length;
            checkPageViews(fund, oneWeekAgo, function(pageViews){
              emailObj['pageViews'] = pageViews.length;
              checkFundApplications(fund, oneWeekAgo, function(apps){
                emailObj['apps'] = apps.length;
                recommendUsers(fund, function(userArray){
                  //Change later when recommended users is better. For now it's dud
                  emailObj['recommendUsers'] = [];
                  emailArray.push(emailObj);
                  fundCallback();
                });
              });
            });
          });
        }, function done(){
            //collected all funds info in an array of objects.
            //node mailer
            var transporter = nodemailer.createTransport(smtpTransport({
             service: 'Gmail',
             auth: {user: 'notifications@silofunds.com',
                   pass: 'ThisIsNotificationsAccount'}
            }));

            // var sendMail = function(toAddress, subject, content, next){
            //   var mailOptions = {
            //      from: 'Silofunds <james.morrill.6@gmail.com>',
            //      to: userEmail,
            //      subject: 'Silo Weekly Newsletter',
            //      html: content
            //   };
            //
            // };
            var locals = {
               email_array: emailArray,
               unsubscribe_link: "http://silofunds.com/user/email-unsubscribe/" + user.id
            };
            var templatePath = path.join(process.cwd(), 'fund-email-templates');
            var template = new EmailTemplate(templatePath);
            template.render(locals, function(err, results){
              if (err) {
                 firstCallback();
                 return console.error(err);
              }
              transporter.sendMail({
                from: 'Silofunds',
                to: user.email,
                subject: 'Silo Weekly Newsletter',
                html: results.html
              }, function(err, responseStatus){
                if (err) {
                 console.error(err);
                 firstCallback();
                }
                else{
                  console.log("SUCCESS");
                  console.log(responseStatus.message);
                  firstCallback();
                }

              });
            });
        });
      });
    });
  });
}
function recommendUsers(fund, callback){
  var queryOptions = {
    "filtered": {
      "filter": {
        "bool": {
          "should": { "match_all": {} }
        }
      }
    }
  };
  if (fund.minimum_age || fund.maximum_age) {
    var todayDate = new Date();
    var userBirthday = new Date();
    var lowerBoundBirthDate = todayDate.getFullYear() - fund.minimum_age;
    var upperBoundBirthdate = todayDate.getFullYear() - fund.maximum_age;
    var lowerBirthdaySeconds = userBirthday.setFullYear(lowerBoundBirthDate);
    var upperBirthdaySeconds = userBirthday.setFullYear(upperBoundBirthdate);
    var lowerDate = new Date(lowerBirthdaySeconds);
    var upperDate = new Date(upperBirthdaySeconds);
    var queryOptionsShouldArr = [
      {
        "range": {
          "date_of_birth": {
            "gte": lowerDate
          }
        }
      },
      {
        "range": {
          "date_of_birth": {
            "lte": upperDate
          }
        }
      }
    ];
    queryOptions.filtered.filter.bool.should = queryOptionsShouldArr;
  }
  queryOptions.filtered.query = {
    "bool": {
      "should": []
    }
  };
    var searchFields = ['country_of_residence','religion','subject','target_degree','required_degree','required_university','target_university','gender'];
    for (var i = 0; i< searchFields.length; i++) {
      var key = searchFields[i];
      var notAge = key !== "date_of_birth";
      var notReligion = key !== "religion";
      var notGender = key !== 'gender';


      if (notAge) {
        var matchObj = {
          "match": {}
        };

        if (fund[key]){
          if(Array.isArray(fund[key])){
            if(fund[key].indexOf('all') < 0 && fund[key].indexOf('All') < 0){
              if (key === 'required_degree') {
                matchObj.match.previous_degree = fund[key].join(', ');
              } else if (key === 'required_university') {
                matchObj.match.previous_university = fund[key].join(', ');
              } else {
                matchObj.match[key] = fund[key].join(', ');
              }

              queryOptions.filtered.query.bool.should.push(matchObj);
            }
          }
          if(typeof fund[key] === 'string'){
            if(fund[key].toLowerCase() === 'all'){
              matchObj.match[key] = fund[key];
              queryOptions.filtered.query.bool.should.push(matchObj);
            }
          }
        }
      }
    }
    es.search({
      index: "users",
      type: "user",
      body: {
        "size": 2,
        "query": queryOptions
      }
    }).then(function(resp){
      var userArray = resp.hits.hits.map(function(hit) {
        var fields  =  ["username","profile_picture","description","date_of_birth","subject", "country_of_residence","target_country","previous_degree", "target_degree", "previous_university", "target_university","religion","funding_needed","organisation_or_user"];
        var hash = {};
        for (var i = 0; i < fields.length ; i++) {
          hash[fields[i]] = hit._source[fields[i]];
        }
        // Sync id separately, because it is hit._id, NOT hit._source.id
        hash.id = hit._id;
        return hash;
      });
      callback(userArray);
    });
}
function checkFundApplications(fund, oneWeekAgo, callback){
  models.applications.findAll({where:{fund_id: fund.id, created_at: {$gt: oneWeekAgo}}}).then(function(apps){
    callback(apps);
  });
}
function checkPageViews(fund, oneWeekAgo, callback){
  models.page_views.findAll({where:{fund_id: fund.id, created_at: {$gt: oneWeekAgo}}}).then(function(pageViews){
    callback(pageViews);
  });
}
function checkFavourite(fund, oneWeekAgo, callback){
  models.favourite_funds.findAll({where: {fund_id: fund.id, created_at: {$gt: oneWeekAgo }}}).then(function(favouriteFunds){
    callback(favouriteFunds);
  });
}
// function findOneWeekAgo(fund, model, object, callback){
//   models[model].findAll({where: {fund_id: fund.id, created_at: {$gt: oneWeekAgo}}}).then(function(object){
//     callback(object);
//   });
// }
function weeklyStudentNewsLetter(){
models.users.findAll({where: {organisation_or_user: null}}).then(function(users){
    //student users - check for campaign views, how many applications you made, donations, recommended funds.
    console.log("WEEKLY STUDENT NEWSLETTER");
    console.log("USER LEGNTH", users.length);
    async.each(users, function(user, callback){
      if(user.email_updates){
        checkDonations(user, function(donation_array){
          checkCampaignViews(user, function(page_view_array){
            recommendUserFunds(user, function(funds){
              checkApplications(user, function(apps){
                //node mailer
                var transporter = nodemailer.createTransport(smtpTransport({
                 service: 'Gmail',
                 auth: {user: 'notifications@silofunds.com',
                       pass: 'ThisIsNotificationsAccount'}
                }));

                // var sendMail = function(toAddress, subject, content, next){
                //   var mailOptions = {
                //      from: 'Silofunds <james.morrill.6@gmail.com>',
                //      to: userEmail,
                //      subject: 'Silo Weekly Newsletter',
                //      html: content
                //   };
                //
                // };
                var locals = {
                  application_number: apps.length,
                  fund_description_1: funds[0].title ,
                  fund_link_1: "http://www.silofunds.com/organisation/options/" + funds[0].id + '/email_clicked/' + user.id,
                  fund_description_2: funds[1].title ,
                  fund_link_2: "http://www.silofunds.com/organisation/options/" + funds[1].id + '/email_clicked/' + user.id,
                  fund_description_3:  funds[2].title ,
                  fund_link_3: "http://www.silofunds.com/organisation/options/" + funds[2].id + '/email_clicked/' + user.id,
                  fund_description_4:  funds[3].title,
                  fund_link_4: "http://www.silofunds.com/organisation/options/" + funds[3].id + '/email_clicked/' + user.id ,
                  page_views:  page_view_array.length ,
                  donations:  donation_array.length,
                  user_id: user.id,
                  unsubscribe_link: "http://silofunds.com/user/email-unsubscribe/" + user.id
                };
                var templatePath = path.join(process.cwd(), 'email-templates');
                var template = new EmailTemplate(templatePath);
                template.render(locals, function(err, results){
                  if (err) {
                     return console.error(err);
                  }
                  transporter.sendMail({
                    from: 'Silofunds <notifications@silofunds.com>',
                    to: user.email,
                    subject: 'Silo Weekly Newsletter',
                    html: results.html
                  }, function(err, responseStatus){
                    if (err) {
                      return console.error(err);
                    }
                    console.log("SUCCESS");
                    console.log(responseStatus);
                  });
                });
              });
            });
          });
        });
      }
    });

  });
}

function checkApplications(user, callback){
  var oneDay = 24*60*60*1000;
  var nowDate = Date.now();
  var oneWeekAgo = new Date();
  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  models.applications.findAll({where: {user_id: user.id, created_at: {$gt: oneWeekAgo }}}).then(function(apps){
    callback(apps);
  });
}
function checkDonations(user, callback){
  var oneDay = 24*60*60*1000;
  var nowDate = Date.now();
  var oneWeekAgo = new Date();
  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  models.stripe_users.find({where: {user_id: user.id}}).then(function(stripe_user){
    if(stripe_user){
      models.stripe_charges.findAll({where: {destination_id: stripe_user.stripe_user_id, created_at:{$gt: oneWeekAgo}}}).then(function(donation_array){
        callback(donation_array);
      });
    }
    else{
      callback(false);
    }

  });
}
function recommendUserFunds(user, callback){
  var searchFields = ['country_of_residence','religion','subject','previous_degree','target_degree','previous_university','target_university','gender'];
  var age;

  if(user.date_of_birth){
    var birthDate = new Date(user.date_of_birth).getTime();
    var nowDate = new Date().getTime();
    age = Math.floor((nowDate - birthDate) / 31536000000);
  }
  var minimum_amount;
  if(user.funding_needed){
    minimum_amount = user.funding_needed * 0.6;
  }
  var queryOptions = {
    "filtered": {
      "filter": {
        "bool": {
          "should": { "match_all": {} }
        }
      }
    }
  };
  if(age || user.funding_needed || user.gender){
    var queryOptionsShouldArr = [
      {
        "range": {
          "minimum_amount": {
            "lte": minimum_amount
          }
        }
      },
      {
        "range": {
          "maximum_amount": {
            "gte": user.funding_needed
          }
        }
      },
      {
        "range": {
          "minimum_age": {
            "lte": age
          }
        }
      },
      {
        "range": {
          "maximum_amount": {
            "gte": age
          }
        }
      }
    ];
    queryOptions.filtered.filter.bool.should = queryOptionsShouldArr;
  }

  queryOptions.filtered.query = {
    "bool": {
      "should": []
    },
  };

  userChange = user.get();
  for (var i = 0; i< searchFields.length; i++) {
    var key = searchFields[i];
    var notAge = key !== "age";
    var notAmount = key !== "funding_needed";
    var notReligion = key !== "religion";
    var notGender = key !== 'gender';

    if (notReligion && notGender) {
      if (user[key]) {
        user[key] = user[key].join(", ");
      }
    }

    if (notAge && notAmount) {
      var matchObj = {
        "match": {}
      };

      if (user[key] !== null) {
        if (key === 'previous_degree') {
          matchObj.match.required_degree = user[key];
        } else if (key === 'previous_university') {
          matchObj.match.required_university = user[key];
        } else {
          matchObj.match[key] = user[key];
        }

        queryOptions.filtered.query.bool.should.push(matchObj);
      }
    }
  }
  es.search({
    index: "funds",
    type: "fund",
    body: {
      "size": 1000,
      "query": queryOptions
    }
  }).then(function(resp){
    var fund_id_list = [];
    var funds = resp.hits.hits.map(function(hit) {
      var fields = ["application_decision_date","application_documents","application_open_date","title","tags","maximum_amount","minimum_amount","country_of_residence","description","duration_of_scholarship","email","application_link","maximum_age","minimum_age","invite_only","interview_date","link","religion","gender","financial_situation","specific_location","subject","target_degree","target_university","required_degree","required_grade","required_university","merit_or_finance","deadline","target_country","number_of_places", "organisation_id"];
      var hash = {};

      for (var i = 0; i < fields.length ; i++) {
        hash[fields[i]] = hit._source[fields[i]];
      }
      // Sync id separately, because it is hit._id, NOT hit._source.id
      hash.id = hit._id;
      fund_id_list.push(hash.organisation_id); // for the WHERE ___ IN ___ query on users table later
      return hash;

    });
    //Add filter for funds which have been clicked by email.

    checkEmailClicked(user, funds, function(funds){

      callback(funds);
    });

  });
}
function checkEmailClicked(user, recommendedFunds, emailCheckCallback){
  models.email_clicks.findAll({where: {user_id: user.id}}).then(function(email_clicked_funds){
    for (var i =0; i < recommendedFunds.length; i++){
      for(var j = 0; j < email_clicked_funds.length; j++){
        if(parseInt(recommendedFunds[i]['id']) === email_clicked_funds[j]['fund_id']){
          recommendedFunds.splice(i, 1);
        }
      }
    }
    funds = recommendedFunds.slice(0,4);
    emailCheckCallback(funds);
  });
}
function checkCampaignViews(user, callback){
  var oneDay = 24*60*60*1000;
  var nowDate = Date.now();
  var oneWeekAgo = new Date();
  oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  models.page_views.findAll({where:{user_id: user.id, created_at: {$gt: oneWeekAgo}}}).then(function(page_view_array){
    callback(page_view_array);
  });
}

function checkIndices(){
  console.log("CHECKING");
  es.checkConnection().then(function(resp) {
    if (resp) {
      Logger.info("Connected to elasticsearch.");
      var countries = require('../resources/countries');
      var religions = require('../resources/religions');
      var degrees = require('../resources/degrees');
      var universities = require('../resources/universities');
      var subjects = require('../resources/subjects');
      es.indices.exists({
       index: 'funds'
     }).catch(function(err) {
       Logger.error("Error checking existence of fund index:");
       Logger.error(err);
     }).then(function(resp) {
       Logger.info("Does the funds index exist?:");
       Logger.error(resp);
       if(resp){
         es.indices.stats('funds').then(function(resp){
           if(resp._all.total.docs.count < 2000){
             models.funds.findAll().then(function(funds) {
               var body = [];
               funds = fund_array_to_json(funds);

               // Prepare body for _bulk processing. Each element in body array HAS to be an object.
               funds.forEach(function(fund) {
                 body.push({'index': {'_index': 'funds', '_type': 'fund', '_id': fund.id}});
                 var wrapper = {};

                 for (var i = 0; i < fields.length ; i++) {
                   wrapper[fields[i]] = fund[fields[i]];
                 }
                 wrapper["suggest_funds"] = { "input": fund.tags };
                 body.push(wrapper);
               });
               console.log("BODY", body);
               es.bulk({
                 body: body
               }, function (err, resp) {
                 Logger.info(resp);
               });
             }).then(function() {
               Logger.info('...Finished sync');
               return true;
             });
           }
           else{
             es.indexExists('users', function(resp){
               if(resp){
                 es.indices.stats('users').then(function(resp){
                   if(resp._all.total.docs.count ===0){
                     es.deleteIndex('users').then(es.createIndex('users')).then(bulkUploadUsers);
                   }
                   else{
                     return true;
                   }
                 });
               }
               else{
                 es.createIndex('users')
                 .then(bulkUploadUsers);
               }
             });
           }
         });
       }
       else{
         es.createIndex('funds')
         .then(bulkUploadFunds)
         .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "rest of the world" }, countries.rotw); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "africa" }, countries.africanCountries); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "eu" }, countries.euCountries); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "middle east" }, countries.meCountries); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "asia" }, countries.asianCountries); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('religions', null, religions.religions); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "undergraduate" }, degrees.undergradDegrees); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "postgraduate masters" }, degrees.gradDegrees); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "uk" }, universities.ukUniversities); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "us" }, universities.usUniversities); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "misc" }, subjects.miscSubjects); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "modern languages" }, subjects.modernLanguages); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "humanities" }, subjects.humanities); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "education" }, subjects.education); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "arts" }, subjects.arts); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "social sciences" }, subjects.socialSciences); })
         .then(bulkUpload)
         .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "science" }, subjects.sciences); })
         .then(bulkUpload)
         .then(es.indexExists('users', function(resp){
           if(resp){
             es.deleteIndex('users')
             .then(es.createIndex('users'))
             .then(bulkUploadUsers);
           }
           else{
             es.createIndex('users')
             .then(bulkUploadUsers);
           }
         }));
       }
     });
    }
  });
}
function checkForFundUnreadMessages() {
  return models.sequelize.query('SELECT user_to, COUNT(*) FROM messages WHERE read_by_recipient = false GROUP BY user_to HAVING COUNT(*) > 0').spread(function(results, metadata) {
    Logger.error("^^^^^^^^^^^^^^^^^^^^^^^^^^^");
    Logger.error(results);
    var userIDList = [];
    var emailStats = {};
    results.forEach(function(result) {
      userIDList.push(result.user_to[0]);
      // Restructure data to be used for sending emails
      emailStats[result.user_to[0]] = {};
      emailStats[result.user_to[0]].unreadCount = result.count;
      emailStats.user_from = result.user_from;
    });
    return models.users.findAll({
      where: { id: userIDList },
      attributes: ['id', 'email', 'username']
    }).then(function(users) {
      users.forEach(function(user) {
        emailStats[user.id].email = user.email;
        var username = user.username.split(' ')[0];
        //send emails here
        var transporter = nodemailer.createTransport(smtpTransport({
         service: 'Gmail',
         auth: {user: 'notifications@silofunds.com',
               pass: 'ThisIsNotificationsAccount'}
        }));
        var mailOptions = {
           from: 'Silofunds <notifications@silofunds.com>',
           to: user.email,
           subject: 'You have new unread messages!',
           html: '<h3>Dear ' + username + '</h3> <p> You are receiving this because you have recieved new messages on our platform. Please click on the following <a href="https://silofunds.com/user/messages">link </a> to read them.</p><img src="https://www.silofunds.com/images/silo-logo-coloured.png" style="width: 250px; height: 137px"> </img>'
        };
        transporter.sendMail(mailOptions, function(error, response) {
            if (error) {
                console.log("Email send failed");
            }
            else {
              console.log("SUCCESS");
            }
        });
      });
    });
  });
}
function checkForRefund(){

  return models.users.findAll({where: {organisation_or_user: null}}).then(function(users){
    async.each(users, function(user, callback){
      //check each user - if funding_accrued < funding_needed && completiont date is over AND they refund, then refund.
      var date = new Date();
      var userId = user.id;
      if(user.completion_date && user.funding_accrued < user.funding_needed && date > user.completion_date && user.refund){
        console.log("Got in");
        user.update({refund: false}).then(function(){
          models.stripe_users.find({where: {user_id: userId}}).then(function(stripe_user){
            var stripe_acct_id = stripe_user.stripe_user_id;
            models.stripe_charges.findAll({where: {destination_id: stripe_acct_id}}).then(function(charge_array){
               asyncRefund(charge_array, callback, user.email, user.username);
            });
          });
        });
      }
      else{
        callback();
      }
    }, function done(){

      return true;
    });
  });
}
function retrieveAllMessagesInRoom(data) {
  return models.messages.findAll({ where: {
    room_name: data.roomName
  }, order: '"created_at" DESC'}).then(function(messages) {
    messages = messages.map(function(message) {
      return message.get();
    });

    Logger.info('Retrieved messages:');
    Logger.info(messages);

    if (users[data.userToID]) {
      users[data.userToID].socket.join(data.roomName);
    }
    users[data.userFromID].socket.join(data.roomName);
    users[data.userFromID].socket.readyToReceiveFrom = data.readyToReceiveFrom;
    Logger.info("user " + data.userFromID + " is ready to receive from " + data.readyToReceiveFrom);

    data.bulk_messages = messages;

    io.sockets.in(data.roomName).emit('bulk get message', data);
  });
}

function createFundIndex(){
  return es.createIndex('funds')
   .then(bulkUploadFunds)
   .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "rest of the world" }, countries.rotw); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "africa" }, countries.africanCountries); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "eu" }, countries.euCountries); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "middle east" }, countries.meCountries); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "asia" }, countries.asianCountries); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('religions', null, religions.religions); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "undergraduate" }, degrees.undergradDegrees); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "postgraduate masters" }, degrees.gradDegrees); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "uk" }, universities.ukUniversities); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "us" }, universities.usUniversities); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "misc" }, subjects.miscSubjects); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "modern languages" }, subjects.modernLanguages); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "humanities" }, subjects.humanities); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "education" }, subjects.education); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "arts" }, subjects.arts); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "social sciences" }, subjects.socialSciences); })
   .then(bulkUpload)
   .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "science" }, subjects.sciences); })
   .then(bulkUpload);
}
function checkUserIndex(){
  return es.indices.exists({
   index: 'users'
 }).catch(function(err) {
   Logger.error("Error checking existence of user index:");
   Logger.error(err);
 }).then(function(resp){
   if(resp){
     es.indices.stats('users').then(function(resp){
       if(resp._all.total.docs.count ===0){
         es.deleteIndex('users').then(es.createIndex('users')).then(bulkUploadUsers);
       }
       else{
         return true;
       }
     });
   }
   else{
     es.createIndex('users').then(bulkUploadUsers);
   }
 });
}
function checkForChanges() {
  var log = 'Last updated: ' + lastUpdate;

  models.funds.findAll({
    where: {
      created_at: {
        $gte: lastUpdate
      }
    },
    order: 'created_at ASC'
  }).then(function(funds) {
    if (funds.length === 0) {
      Logger.info("nothing to update....");
    } else {
      var wrapper = {};
      var body = prepareBulkUploadFunds(funds);

      wrapper.fieldName = 'funds';
      wrapper.body = body;

      bulkUpload(wrapper).then(function() {
        // Timestamp from table rounds down. Here is the correction to avoid duplication.
        var lastUpdateFromTable = funds[funds.length - 1].created_at;
        lastUpdateFromTable.setSeconds(lastUpdateFromTable.getSeconds() + 1);
        lastUpdate = lastUpdateFromTable;
      });
    }
  }).then(function(){
    models.users.findAll({
      where: {
        created_at: {
          $gte: lastUpdate
        },
        organisation_or_user: null
      },
      order: 'created_at ASC'
    }).then(function(users){
      if(users.length === 0){
        Logger.info('nothing to update');
      }else{
        var wrapper = {};
        var body = prepareBulkUploadUsers(users);
        wrapper.fieldName = 'users';
        wrapper.body = body;
        bulkUpload(wrapper).then(function(){
          // Timestamp from table rounds down. Here is the correction to avoid duplication.
          var lastUpdateFromTable = funds[funds.length - 1].created_at;
          lastUpdateFromTable.setSeconds(lastUpdateFromTable.getSeconds() + 1);
          lastUpdate = lastUpdateFromTable;
        });
      }
    });
  });
}

function loadSettingsForBulkPrepFor(typeName, extraOptions, dataSource) {
  var wrapper = {};
  var body = prepareBulkUploadAutocomplete(typeName, elasticsearchModels.autocompleteSettings[typeName], extraOptions, dataSource);

  wrapper.fieldName = typeName;
  wrapper.body = body;
  return wrapper;
}

function prepareBulkUploadFunds(funds) {
  var body = [];
  funds = fund_array_to_json(funds);

  // Prepare body for _bulk processing. Each element in body array HAS to be an object.
  funds.forEach(function(fund) {
    body.push({'index': {'_index': 'funds', '_type': 'fund', '_id': fund.id}});
    var wrapper = {};

    for (var i = 0; i < fields.length ; i++) {
      wrapper[fields[i]] = fund[fields[i]];
    }

    wrapper["suggest_funds"] = { "input": fund.tags };

    body.push(wrapper);
  });

  return body;
}

function prepareBulkUploadUsers(users) {
  var userBody = [];
  users = fund_array_to_json(users);

  // Prepare body for _bulk processing. Each element in body array HAS to be an object.
  users.forEach(function(user) {
    userBody.push({'index': {'_index': 'users', '_type': 'user', '_id': user.id}});
    var wrapper = {};

    for (var i = 0; i < userFields.length ; i++) {
      wrapper[userFields[i]] = user[userFields[i]];
    }

    wrapper.suggest = { "input": user.username };

    userBody.push(wrapper);
  });

  return userBody;
}

function prepareBulkUploadAutocomplete(typeName, keyOptions, extraOptions, dataSource) {
  var bodyArray =[];
  var type = 'autocomplete_' + typeName;

  // Extra field for degrees ("abbreviated_degree") to handle abbreviations
  if (typeName === 'degrees') {
    // Currently only degrees.js has format in array of JSON
    dataSource.forEach(function(data){
      // NOTE: Careful with future Object.prototype keys manipulation
      for (var key in data) {
        var payloadOptions = {};

        payloadOptions[keyOptions.payloadKey] = data[key];

        bodyArray.push({'index': {'_index': 'funds', '_type': type }});
        var wrapper = {};

        wrapper[keyOptions.normalFieldName] = data[key];
        wrapper[keyOptions.suggestFieldName] = { "input": data[key].split(' '), "output": data[key], "payload": payloadOptions};

        if (extraOptions) {
          var extraOptionsKeys = Object.keys(extraOptions);

          for (var i = 0; i < extraOptionsKeys.length; i++) {
            var extraOptionsKey = extraOptionsKeys[i];
            wrapper[extraOptionsKey] = extraOptions[extraOptionsKey];
          }
        }

        // The only thing different from the else case below.
        wrapper.abbreviated_degree = key;

        bodyArray.push(wrapper);
      }
    });
  } else {
    dataSource.forEach(function(data){
      var payloadOptions = {};
      payloadOptions[keyOptions.payloadKey] = data;

      bodyArray.push({'index': {'_index': 'funds', '_type': type }});
      var wrapper = {};

      wrapper[keyOptions.normalFieldName] = data;
      wrapper[keyOptions.suggestFieldName] = { "input": data.split(' '), "output": data, "payload": payloadOptions};

      if (extraOptions) {
        var extraOptionsKeys = Object.keys(extraOptions);

        for (var i = 0; i < extraOptionsKeys.length; i++) {
          var extraOptionsKey = extraOptionsKeys[i];
          wrapper[extraOptionsKey] = extraOptions[extraOptionsKey];
        }
      }

      bodyArray.push(wrapper);
    });
  }

  return bodyArray;
}

function bulkUploadUsers() {
  return models.users.findAll().then(prepareBulkUploadUsers).then(function(body) {
    bulkUpload({
      body: body,
      fieldName: 'users'
    });
  });
}

function bulkUploadFunds() {
  return models.funds.findAll().then(prepareBulkUploadFunds).then(function(body) {
    bulkUpload({
      body: body,
      fieldName: 'funds'
    });
  });
}

function bulkUpload(data) {
  return es.bulk({
            body: data.body
          }).catch(function(err) {
            Logger.info("Error bulk syncing " + data.fieldName + " into funds index:");
            Logger.info(err);
          }).then(function(resp) {
            if (resp) {
              Logger.info("Bulk sync for " + data.fieldName + " complete");
              if (process.env.NODE_ENV == "production") {
                sleep.sleep(3);
              }
              // sleep.sleep(5);
            }
          });
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */
 function asyncRefund(chargeArray, mainCallback, userEmail, username){
   async.each(chargeArray, function(charge, callback){
     stripe.refunds.create({
       charge: charge.charge_id
     }, function(err, refund){
       Logger.error(refund);
       callback();
     });
   }, function done(){
     var transporter = nodemailer.createTransport(smtpTransport({
      service: 'Gmail',
      auth: {user: 'notifications@silofunds.com',
      pass: 'ThisIsNotificationsAccount'}
     }));
     var mailOptions = {
        from: 'Silofunds <notifications@silofunds.com>',
        to: userEmail,
        subject: 'Silo refund',
        html: '<h3>Dear ' + username + '</h3> <p> You have now refunded all your donors, but fear not there are still funds available for you! Check out <a href="http://silofunds.com"> for more.</a> </p><img src="https://www.silofunds.com/images/silo-logo-coloured.png" style="width: 250px; height: 137px"> </img>'
     };
     transporter.sendMail(mailOptions, function(error, response) {
         if (error) {
             console.log("Email send failed");
              mainCallback();
         }
         else {
           console.log("SUCCESS");
            mainCallback();
         }
     });

   });
 }
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
