#!/usr/bin/env node

var app = require('../app');
var debug = require('debug')('potfund:server');
var http = require('http');
var models = require('../models');
var sleep = require('sleep');
var es = require('../elasticsearch');
var elasticsearchModels = require('../elasticsearch/model');

var fund_array_to_json = function(array) {
  var funds = array.map(function(fund) {
    var json = fund.toJSON();
    return json;
  });
  return funds;
};

var fields = ["application_decision_date","application_documents","application_open_date","title","tags","maximum_amount","minimum_amount","country_of_residence","description","duration_of_scholarship","email","application_link","maximum_age","minimum_age","invite_only","interview_date","link","religion","gender","financial_situation","specific_location","subject","target_degree","target_university","required_degree","required_grade","required_university","merit_or_finance","deadline","target_country","number_of_places", "support_type","organisation_id"];
var userFields =  ["username","profile_picture","description","past_work","date_of_birth","subject", "country_of_residence", "target_country", "religion","funding_needed","organisation_or_user", "previous_degree", "previous_university", "target_university", "target_degree","completion_date", "favourite_funds"];

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

var server = http.createServer(app);

/* Socket IO Messaging Component */

var io = require('socket.io')(server);
var users = {};

io.on('connection', function(socket){
  Logger.info('a user connected');

  socket.on('disconnect', function(){
    Logger.info('user disconnected');
  });

  socket.on('private message', function(data) {
    Logger.info("USERS");
    Logger.info(users);

    Logger.info(data);
    if (users[data.userToID]) {
      users[data.userToID].socket.join(data.roomName);
    }
    users[data.userFromID].socket.join(data.roomName);

    var rooms = io.sockets.adapter.rooms;
    Logger.info("Clients in rooms:");
    Logger.info(rooms);



    var user_to_arr = [];
    user_to_arr.push(data.userToID);
    var read_by_recipient = false;

    if (users[data.userToID]) {
      if (users[data.userToID].socket.readyToReceiveFrom == data.userFromID ) {
        read_by_recipient = true;
        data.read_by_recipient = true;
      }
    }

    models.messages.create({
      user_from: data.userFromID,
      user_to: user_to_arr,
      message: data.msg,
      room_name: data.roomName,
      read_by_recipient: read_by_recipient
    });
    io.sockets.in(data.roomName).emit('private message', data);
  });

  socket.on('add user', function(data) {
    users[data.userFrom.id] = { "socket" : socket };
    Logger.info("A new user has been added. Here is the users object:");
    Logger.info(users);
  });

  socket.on('room join', function(data) {

  });

  socket.on('get messages', function(data) {
    var userToID_arr = [];
    userToID_arr.push(data.userToID);
    var userFromID_arr = [];
    userFromID_arr.push(data.userFromID);

    // NOTE: readyToReceiveFrom also means it has read latest message
    console.log(data.userToID);
    models.users.findById(data.userToID).then(function(userTo) {
      userTo = userTo.get();

      data.userTo = userTo;

      models.messages.findAll({ where: {
        room_name: data.roomName,
        user_to: userFromID_arr
      }}).then(function(messages) {
        if (typeof messages !== 'undefined' && messages.length > 0) {
          // the array is defined and has at least one element

          messages[messages.length - 1].update({ read_by_recipient: true }).then(function() {
            models.messages.findAll({ where: {
              room_name: data.roomName
            }}).then(function(messages) {
              messages = messages.map(function(message) {
                return message.get();
              });

              Logger.info('Retrieved messages:');
              Logger.info(messages);

              if (users[data.userToID]) {
                users[data.userToID].socket.join(data.roomName);
              }
              users[data.userFromID].socket.join(data.roomName);
              users[data.userFromID].socket.readyToReceiveFrom = data.readyToReceiveFrom;
              Logger.info("user " + data.userFromID + " is ready to receive from " + data.readyToReceiveFrom);

              data.bulk_messages = messages;

              io.sockets.in(data.roomName).emit('bulk get message', data);
            });
          });
        } else {
          models.messages.findAll({ where: {
            room_name: data.roomName
          }}).then(function(messages) {
            messages = messages.map(function(message) {
              return message.get();
            });

            Logger.info('Retrieved messages:');
            Logger.info(messages);

            if (users[data.userToID]) {
              users[data.userToID].socket.join(data.roomName);
            }
            users[data.userFromID].socket.join(data.roomName);
            users[data.userFromID].socket.readyToReceiveFrom = data.readyToReceiveFrom;
            Logger.info("user " + data.userFromID + " is ready to receive from " + data.readyToReceiveFrom);

            data.bulk_messages = messages;

            io.sockets.in(data.roomName).emit('bulk get message', data);
          });
        }
      });
    });
  });
});

/* ---------------------------- */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

es.checkConnection().then(function(resp) {
  if (resp) {
    Logger.info("Connected to elasticsearch.");
    var countries = require('../resources/countries');
    var religions = require('../resources/religions');
    var degrees = require('../resources/degrees');
    var universities = require('../resources/universities');
    var subjects = require('../resources/subjects');

    es.indexExists('funds')
      .then(es.deleteIndex('funds'))
      .then(es.createIndex('funds'))
      .then(bulkUploadFunds)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "rest of the world" }, countries.rotw); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "africa" }, countries.africanCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "eu" }, countries.euCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "middle east" }, countries.meCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('countries', { "country_category": "asia" }, countries.asianCountries); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('religions', null, religions.religions); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "undergraduate" }, degrees.undergradDegrees); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('degrees', { "degree_category": "postgraduate masters" }, degrees.gradDegrees); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "uk" }, universities.ukUniversities); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('universities', { "university_category": "us" }, universities.usUniversities); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "misc" }, subjects.miscSubjects); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "modern languages" }, subjects.modernLanguages); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "humanities" }, subjects.humanities); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "education" }, subjects.education); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "arts" }, subjects.arts); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "social sciences" }, subjects.socialSciences); })
      .then(bulkUpload)
      .then(function() { return loadSettingsForBulkPrepFor('subjects', { "subject_category": "science" }, subjects.sciences); })
      .then(bulkUpload);

    es.indexExists('users')
      .then(es.deleteIndex('users'))
      .then(es.createIndex('users'))
      .then(bulkUploadUsers);
  }
});

// TODO: check queue for duplications! Duplications MAY occur due to timestamp rounding error
// TODO: Eventually have to implement queuing system? Querying whole funds table is high volume.

var CronJob = require('cron').CronJob;
var lastUpdate = new Date();
var job = new CronJob('*/30 * * * * *', checkForChanges, null, true);

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
///////////////////////    Helper functions    /////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

function checkForChanges() {
  var log = 'Last updated: ' + lastUpdate;

  models.funds.findAll({
    where: {
      created_at: {
        $gte: lastUpdate
      }
    },
    order: 'created_at ASC'
  }).then(function(funds) {
    if (funds.length === 0) {
      Logger.info("nothing to update....");
    } else {
      var wrapper = {};
      var body = prepareBulkUploadFunds(funds);

      wrapper.fieldName = 'funds';
      wrapper.body = body;

      bulkUpload(wrapper).then(function() {
        // Timestamp from table rounds down. Here is the correction to avoid duplication.
        var lastUpdateFromTable = funds[funds.length - 1].created_at;
        lastUpdateFromTable.setSeconds(lastUpdateFromTable.getSeconds() + 1);
        lastUpdate = lastUpdateFromTable;
      });
    }
  });
}

function loadSettingsForBulkPrepFor(typeName, extraOptions, dataSource) {
  var wrapper = {};
  var body = prepareBulkUploadAutocomplete(typeName, elasticsearchModels.autocompleteSettings[typeName], extraOptions, dataSource);

  wrapper.fieldName = typeName;
  wrapper.body = body;
  return wrapper;
}

function prepareBulkUploadFunds(funds) {
  var body = [];
  funds = fund_array_to_json(funds);

  // Prepare body for _bulk processing. Each element in body array HAS to be an object.
  funds.forEach(function(fund) {
    body.push({'index': {'_index': 'funds', '_type': 'fund', '_id': fund.id}});
    var wrapper = {};

    for (var i = 0; i < fields.length ; i++) {
      wrapper[fields[i]] = fund[fields[i]];
    }

    wrapper["suggest_funds"] = { "input": fund.tags };

    body.push(wrapper);
  });

  return body;
}

function prepareBulkUploadUsers(users) {
  var userBody = [];
  users = fund_array_to_json(users);

  // Prepare body for _bulk processing. Each element in body array HAS to be an object.
  users.forEach(function(user) {
    userBody.push({'index': {'_index': 'users', '_type': 'user', '_id': user.id}});
    var wrapper = {};

    for (var i = 0; i < userFields.length ; i++) {
      wrapper[userFields[i]] = user[userFields[i]];
    }

    wrapper.suggest = { "input": user.username };

    userBody.push(wrapper);
  });

  return userBody;
}

function prepareBulkUploadAutocomplete(typeName, keyOptions, extraOptions, dataSource) {
  var bodyArray =[];
  var type = 'autocomplete_' + typeName;

  // Extra field for degrees ("abbreviated_degree") to handle abbreviations
  if (typeName === 'degrees') {
    // Currently only degrees.js has format in array of JSON
    dataSource.forEach(function(data){
      // NOTE: Careful with future Object.prototype keys manipulation
      for (var key in data) {
        var payloadOptions = {};

        payloadOptions[keyOptions.payloadKey] = data[key];

        bodyArray.push({'index': {'_index': 'funds', '_type': type }});
        var wrapper = {};

        wrapper[keyOptions.normalFieldName] = data[key];
        wrapper[keyOptions.suggestFieldName] = { "input": data[key].split(' '), "output": data[key], "payload": payloadOptions};

        if (extraOptions) {
          var extraOptionsKeys = Object.keys(extraOptions);

          for (var i = 0; i < extraOptionsKeys.length; i++) {
            var extraOptionsKey = extraOptionsKeys[i];
            wrapper[extraOptionsKey] = extraOptions[extraOptionsKey];
          }
        }

        // The only thing different from the else case below.
        wrapper.abbreviated_degree = key;

        bodyArray.push(wrapper);
      }
    });
  } else {
    dataSource.forEach(function(data){
      var payloadOptions = {};
      payloadOptions[keyOptions.payloadKey] = data;

      bodyArray.push({'index': {'_index': 'funds', '_type': type }});
      var wrapper = {};

      wrapper[keyOptions.normalFieldName] = data;
      wrapper[keyOptions.suggestFieldName] = { "input": data.split(' '), "output": data, "payload": payloadOptions};

      if (extraOptions) {
        var extraOptionsKeys = Object.keys(extraOptions);

        for (var i = 0; i < extraOptionsKeys.length; i++) {
          var extraOptionsKey = extraOptionsKeys[i];
          wrapper[extraOptionsKey] = extraOptions[extraOptionsKey];
        }
      }

      bodyArray.push(wrapper);
    });
  }

  return bodyArray;
}

function bulkUploadUsers() {
  return models.users.findAll().then(prepareBulkUploadUsers).then(function(body) {
    bulkUpload({
      body: body,
      fieldName: 'users'
    });
  });
}

function bulkUploadFunds() {
  return models.funds.findAll().then(prepareBulkUploadFunds).then(function(body) {
    bulkUpload({
      body: body,
      fieldName: 'funds'
    });
  });
}

function bulkUpload(data) {
  return es.bulk({
            body: data.body
          }).catch(function(err) {
            Logger.info("Error bulk syncing " + data.fieldName + " into funds index:");
            Logger.info(err);
          }).then(function(resp) {
            if (resp) {
              Logger.info("Bulk sync for " + data.fieldName + " complete");
            }
          });
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
